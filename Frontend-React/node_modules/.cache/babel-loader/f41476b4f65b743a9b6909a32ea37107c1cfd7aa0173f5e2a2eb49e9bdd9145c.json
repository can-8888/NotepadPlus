{"ast":null,"code":"import * as signalR from '@microsoft/signalr';\nclass SignalRService {\n  constructor() {\n    this.connection = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n  }\n  async startConnection() {\n    try {\n      var _this$connection;\n      if (((_this$connection = this.connection) === null || _this$connection === void 0 ? void 0 : _this$connection.state) === signalR.HubConnectionState.Connected) {\n        console.log('SignalR already connected');\n        return;\n      }\n      const baseUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000';\n      const userId = localStorage.getItem('userId');\n      const token = localStorage.getItem('token');\n      if (!userId || !token) {\n        console.error('Missing userId or token');\n        return;\n      }\n      console.log('Configuring SignalR connection...');\n      this.connection = new signalR.HubConnectionBuilder().withUrl(`${baseUrl}/notificationHub`, {\n        transport: signalR.HttpTransportType.WebSockets,\n        skipNegotiation: false,\n        headers: {\n          'UserId': userId,\n          'Authorization': `Bearer ${token}`\n        }\n      }).withAutomaticReconnect({\n        nextRetryDelayInMilliseconds: retryContext => {\n          if (retryContext.previousRetryCount >= this.maxReconnectAttempts) {\n            return null;\n          }\n          return Math.min(1000 * Math.pow(2, retryContext.previousRetryCount), 30000);\n        }\n      }).configureLogging(signalR.LogLevel.Debug).build();\n      this.setupConnectionHandlers();\n      console.log('Starting SignalR connection...');\n      await this.connection.start();\n      console.log('SignalR Connected successfully');\n\n      // Join user group after successful connection\n      await this.connection.invoke('JoinUserGroup', userId);\n    } catch (err) {\n      console.error('Error starting SignalR connection:', err);\n      throw err;\n    }\n  }\n  setupConnectionHandlers() {\n    if (!this.connection) return;\n    this.connection.onreconnecting(error => {\n      console.log('SignalR reconnecting:', error);\n      this.reconnectAttempts++;\n    });\n    this.connection.onreconnected(connectionId => {\n      console.log('SignalR reconnected. Connection ID:', connectionId);\n      this.reconnectAttempts = 0;\n    });\n    this.connection.onclose(error => {\n      console.log('SignalR connection closed:', error);\n      if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n        console.log('Max reconnection attempts reached');\n        window.location.href = '/login';\n      }\n    });\n  }\n  isConnected() {\n    var _this$connection2;\n    return ((_this$connection2 = this.connection) === null || _this$connection2 === void 0 ? void 0 : _this$connection2.state) === signalR.HubConnectionState.Connected;\n  }\n  onNotification(callback) {\n    var _this$connection3;\n    (_this$connection3 = this.connection) === null || _this$connection3 === void 0 ? void 0 : _this$connection3.on('ReceiveNotification', notification => {\n      console.log('Received notification:', notification);\n      callback(notification);\n    });\n  }\n  offNotification() {\n    var _this$connection4;\n    (_this$connection4 = this.connection) === null || _this$connection4 === void 0 ? void 0 : _this$connection4.off('ReceiveNotification');\n  }\n  addNoteUpdateListener(callback) {\n    var _this$connection5;\n    (_this$connection5 = this.connection) === null || _this$connection5 === void 0 ? void 0 : _this$connection5.on('NoteUpdated', callback);\n  }\n  addNoteDeleteListener(callback) {\n    var _this$connection6;\n    (_this$connection6 = this.connection) === null || _this$connection6 === void 0 ? void 0 : _this$connection6.on('NoteDeleted', callback);\n  }\n  async stopConnection() {\n    try {\n      var _this$connection7;\n      await ((_this$connection7 = this.connection) === null || _this$connection7 === void 0 ? void 0 : _this$connection7.stop());\n      console.log('SignalR Disconnected');\n    } catch (err) {\n      console.error('Error stopping SignalR connection:', err);\n      throw err;\n    }\n  }\n  async reconnect() {\n    if (!this.isConnected()) {\n      await this.startConnection();\n    }\n  }\n}\nexport const signalRService = new SignalRService();","map":{"version":3,"names":["signalR","SignalRService","constructor","connection","reconnectAttempts","maxReconnectAttempts","startConnection","_this$connection","state","HubConnectionState","Connected","console","log","baseUrl","process","env","REACT_APP_API_URL","userId","localStorage","getItem","token","error","HubConnectionBuilder","withUrl","transport","HttpTransportType","WebSockets","skipNegotiation","headers","withAutomaticReconnect","nextRetryDelayInMilliseconds","retryContext","previousRetryCount","Math","min","pow","configureLogging","LogLevel","Debug","build","setupConnectionHandlers","start","invoke","err","onreconnecting","onreconnected","connectionId","onclose","window","location","href","isConnected","_this$connection2","onNotification","callback","_this$connection3","on","notification","offNotification","_this$connection4","off","addNoteUpdateListener","_this$connection5","addNoteDeleteListener","_this$connection6","stopConnection","_this$connection7","stop","reconnect","signalRService"],"sources":["D:/_master/v5/NotepadPlus/Frontend-React/src/services/signalRService.ts"],"sourcesContent":["import * as signalR from '@microsoft/signalr';\r\nimport { api } from './api';\r\nimport { Notification } from '../types/Notification';\r\nimport { NotificationType } from '../types/NotificationType';\r\n\r\nclass SignalRService {\r\n    private connection: signalR.HubConnection | null = null;\r\n    private reconnectAttempts = 0;\r\n    private readonly maxReconnectAttempts = 5;\r\n\r\n    public async startConnection(): Promise<void> {\r\n        try {\r\n            if (this.connection?.state === signalR.HubConnectionState.Connected) {\r\n                console.log('SignalR already connected');\r\n                return;\r\n            }\r\n\r\n            const baseUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000';\r\n            const userId = localStorage.getItem('userId');\r\n            const token = localStorage.getItem('token');\r\n            \r\n            if (!userId || !token) {\r\n                console.error('Missing userId or token');\r\n                return;\r\n            }\r\n\r\n            console.log('Configuring SignalR connection...');\r\n            \r\n            this.connection = new signalR.HubConnectionBuilder()\r\n                .withUrl(`${baseUrl}/notificationHub`, {\r\n                    transport: signalR.HttpTransportType.WebSockets,\r\n                    skipNegotiation: false,\r\n                    headers: {\r\n                        'UserId': userId,\r\n                        'Authorization': `Bearer ${token}`\r\n                    }\r\n                })\r\n                .withAutomaticReconnect({\r\n                    nextRetryDelayInMilliseconds: retryContext => {\r\n                        if (retryContext.previousRetryCount >= this.maxReconnectAttempts) {\r\n                            return null;\r\n                        }\r\n                        return Math.min(1000 * Math.pow(2, retryContext.previousRetryCount), 30000);\r\n                    }\r\n                })\r\n                .configureLogging(signalR.LogLevel.Debug)\r\n                .build();\r\n\r\n            this.setupConnectionHandlers();\r\n\r\n            console.log('Starting SignalR connection...');\r\n            await this.connection.start();\r\n            console.log('SignalR Connected successfully');\r\n\r\n            // Join user group after successful connection\r\n            await this.connection.invoke('JoinUserGroup', userId);\r\n        } catch (err) {\r\n            console.error('Error starting SignalR connection:', err);\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    private setupConnectionHandlers(): void {\r\n        if (!this.connection) return;\r\n\r\n        this.connection.onreconnecting(error => {\r\n            console.log('SignalR reconnecting:', error);\r\n            this.reconnectAttempts++;\r\n        });\r\n\r\n        this.connection.onreconnected(connectionId => {\r\n            console.log('SignalR reconnected. Connection ID:', connectionId);\r\n            this.reconnectAttempts = 0;\r\n        });\r\n\r\n        this.connection.onclose(error => {\r\n            console.log('SignalR connection closed:', error);\r\n            if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n                console.log('Max reconnection attempts reached');\r\n                window.location.href = '/login';\r\n            }\r\n        });\r\n    }\r\n\r\n    public isConnected(): boolean {\r\n        return this.connection?.state === signalR.HubConnectionState.Connected;\r\n    }\r\n\r\n    public onNotification(callback: (notification: Notification) => void): void {\r\n        this.connection?.on('ReceiveNotification', (notification: Notification) => {\r\n            console.log('Received notification:', notification);\r\n            callback(notification);\r\n        });\r\n    }\r\n\r\n    public offNotification(): void {\r\n        this.connection?.off('ReceiveNotification');\r\n    }\r\n\r\n    public addNoteUpdateListener(callback: (note: any) => void): void {\r\n        this.connection?.on('NoteUpdated', callback);\r\n    }\r\n\r\n    public addNoteDeleteListener(callback: (noteId: number) => void): void {\r\n        this.connection?.on('NoteDeleted', callback);\r\n    }\r\n\r\n    public async stopConnection(): Promise<void> {\r\n        try {\r\n            await this.connection?.stop();\r\n            console.log('SignalR Disconnected');\r\n        } catch (err) {\r\n            console.error('Error stopping SignalR connection:', err);\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    public async reconnect(): Promise<void> {\r\n        if (!this.isConnected()) {\r\n            await this.startConnection();\r\n        }\r\n    }\r\n}\r\n\r\nexport const signalRService = new SignalRService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}