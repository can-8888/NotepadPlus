{"ast":null,"code":"const API_URL = 'http://localhost:5000/api';\n\n// Update the user type to match C# casing\n\n// Update the getCurrentUser function\nconst getCurrentUser = () => {\n  const userJson = localStorage.getItem('user');\n  console.log('User from localStorage:', userJson);\n  if (!userJson) return null;\n  try {\n    const user = JSON.parse(userJson);\n    console.log('Parsed user:', user);\n    // Update validation to check for Id instead of id\n    if (!user || typeof user.Id !== 'number') {\n      console.log('Invalid user object:', user);\n      return null;\n    }\n    return user;\n  } catch (err) {\n    console.error('Error parsing user:', err);\n    return null;\n  }\n};\nexport const api = {\n  // Auth operations\n  login: async credentials => {\n    const response = await fetch(`${API_URL}/auth/login`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(credentials)\n    });\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(error || 'Login failed');\n    }\n    const userData = await response.json();\n\n    // Format the user data to handle both casings\n    const formattedUser = {\n      id: userData.id || userData.Id,\n      username: userData.username || userData.Username,\n      email: userData.email || userData.Email,\n      createdAt: new Date(userData.createdAt || userData.CreatedAt),\n      // Keep the original properties for backward compatibility\n      Id: userData.Id || userData.id,\n      Username: userData.Username || userData.username,\n      Email: userData.Email || userData.email,\n      CreatedAt: userData.CreatedAt || userData.createdAt\n    };\n\n    // Store the formatted user data in localStorage\n    localStorage.setItem('user', JSON.stringify(formattedUser));\n    return formattedUser;\n  },\n  register: async userData => {\n    const response = await fetch(`${API_URL}/auth/register`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(userData)\n    });\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(error || 'Registration failed');\n    }\n    return response.json();\n  },\n  // Note operations\n  getNotes: async () => {\n    const user = getCurrentUser();\n    if (!(user !== null && user !== void 0 && user.Id)) {\n      throw new Error('User not authenticated');\n    }\n    console.log('Fetching notes for user:', user.Id);\n    const response = await fetch(`${API_URL}/notes`, {\n      headers: {\n        'Content-Type': 'application/json',\n        'UserId': user.Id.toString()\n      }\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch notes');\n    }\n    const notes = await response.json();\n    console.log('Raw API response:', notes);\n\n    // Convert from C# casing to TypeScript casing and filter by current user\n    const formattedNotes = notes.map(note => ({\n      id: note.id || note.Id,\n      title: note.title || note.Title,\n      content: note.content || note.Content,\n      category: note.category || note.Category,\n      createdAt: new Date(note.createdAt || note.CreatedAt),\n      updatedAt: new Date(note.updatedAt || note.UpdatedAt),\n      userId: note.userId || note.UserId,\n      isPublic: note.isPublic || note.IsPublic,\n      user: note.user || note.User\n    })).filter(note => note.userId === user.Id); // Properly type the note parameter\n\n    console.log('Formatted and filtered notes:', formattedNotes);\n    return formattedNotes;\n  },\n  createNote: async note => {\n    const user = getCurrentUser();\n    if (!(user !== null && user !== void 0 && user.Id)) {\n      throw new Error('User not authenticated');\n    }\n    console.log('Creating note with data:', {\n      ...note,\n      userId: user.Id\n    });\n    const response = await fetch(`${API_URL}/notes`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'UserId': user.Id.toString()\n      },\n      body: JSON.stringify({\n        title: note.title || '',\n        content: note.content || '',\n        category: note.category || '',\n        userId: user.Id\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      console.error('Create note error:', error);\n      throw new Error(error.message || 'Failed to create note');\n    }\n    const createdNote = await response.json();\n    console.log('Server response:', createdNote);\n\n    // Convert from C# casing to TypeScript casing\n    const formattedNote = {\n      id: createdNote.id || createdNote.Id,\n      title: createdNote.title || createdNote.Title,\n      content: createdNote.content || createdNote.Content,\n      category: createdNote.category || createdNote.Category,\n      createdAt: new Date(createdNote.createdAt || createdNote.CreatedAt),\n      updatedAt: new Date(createdNote.updatedAt || createdNote.UpdatedAt),\n      userId: createdNote.userId || createdNote.UserId,\n      isPublic: createdNote.isPublic || createdNote.IsPublic,\n      user: createdNote.user || createdNote.User\n    };\n    console.log('Formatted note:', formattedNote);\n    return formattedNote;\n  },\n  updateNote: async (id, note) => {\n    try {\n      const response = await fetch(`${API_URL}/notes/${id}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          id,\n          title: note.title || '',\n          content: note.content || '',\n          category: note.category || '',\n          userId: note.userId\n        })\n      });\n      if (!response.ok) {\n        const error = await response.text();\n        throw new Error(error || 'Failed to update note');\n      }\n      const updatedNote = await response.json();\n      return {\n        ...updatedNote,\n        createdAt: new Date(updatedNote.createdAt),\n        updatedAt: new Date(updatedNote.updatedAt)\n      };\n    } catch (err) {\n      console.error('Update error:', err);\n      throw err;\n    }\n  },\n  deleteNote: async id => {\n    const response = await fetch(`${API_URL}/notes/${id}`, {\n      method: 'DELETE'\n    });\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(error || 'Failed to delete note');\n    }\n  },\n  shareNote: async (noteId, collaboratorId) => {\n    const user = getCurrentUser();\n    if (!(user !== null && user !== void 0 && user.Id)) {\n      // Changed from id to Id\n      throw new Error('User not authenticated');\n    }\n    const response = await fetch(`${API_URL}/notes/share`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'UserId': user.Id.toString() // Changed from id to Id\n      },\n      body: JSON.stringify({\n        noteId,\n        collaboratorId\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to share note');\n    }\n  },\n  getSharedNotes: async () => {\n    const user = getCurrentUser();\n    if (!(user !== null && user !== void 0 && user.Id)) {\n      // Changed from id to Id\n      throw new Error('User not authenticated');\n    }\n    const response = await fetch(`${API_URL}/notes/shared`, {\n      headers: {\n        'Content-Type': 'application/json',\n        'UserId': user.Id.toString() // Changed from id to Id\n      }\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch shared notes');\n    }\n    const notes = await response.json();\n    return notes.map(note => ({\n      ...note,\n      createdAt: new Date(note.createdAt),\n      updatedAt: new Date(note.updatedAt)\n    }));\n  },\n  makeNotePublic: async id => {\n    const user = getCurrentUser();\n    if (!(user !== null && user !== void 0 && user.Id)) {\n      // Changed from id to Id\n      throw new Error('User not authenticated');\n    }\n    const response = await fetch(`${API_URL}/notes/${id}/make-public`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'UserId': user.Id.toString() // Changed from id to Id\n      }\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to make note public');\n    }\n  },\n  searchUsers: async searchTerm => {\n    const user = getCurrentUser();\n    if (!(user !== null && user !== void 0 && user.Id)) {\n      throw new Error('User not authenticated');\n    }\n    const response = await fetch(`${API_URL}/users/search?term=${encodeURIComponent(searchTerm)}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        'UserId': user.Id.toString()\n      }\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to search users');\n    }\n    return response.json();\n  }\n};","map":{"version":3,"names":["API_URL","getCurrentUser","userJson","localStorage","getItem","console","log","user","JSON","parse","Id","err","error","api","login","credentials","response","fetch","method","headers","body","stringify","ok","text","Error","userData","json","formattedUser","id","username","Username","email","Email","createdAt","Date","CreatedAt","setItem","register","getNotes","toString","message","notes","formattedNotes","map","note","title","Title","content","Content","category","Category","updatedAt","UpdatedAt","userId","UserId","isPublic","IsPublic","User","filter","createNote","createdNote","formattedNote","updateNote","updatedNote","deleteNote","shareNote","noteId","collaboratorId","getSharedNotes","makeNotePublic","searchUsers","searchTerm","encodeURIComponent"],"sources":["D:/_master/v5/notepad-plus/src/services/api.ts"],"sourcesContent":["import { Note, User } from '../types/Note';\r\nimport { LoginRequest, RegisterRequest } from '../types/Auth';\r\n\r\nconst API_URL = 'http://localhost:5000/api';\r\n\r\n// Update the user type to match C# casing\r\ninterface CurrentUser {\r\n    Id: number;  // Changed from id to Id\r\n    Username: string;  // Changed from username to Username\r\n}\r\n\r\n// Update the getCurrentUser function\r\nconst getCurrentUser = (): CurrentUser | null => {\r\n    const userJson = localStorage.getItem('user');\r\n    console.log('User from localStorage:', userJson);\r\n    if (!userJson) return null;\r\n    try {\r\n        const user = JSON.parse(userJson);\r\n        console.log('Parsed user:', user);\r\n        // Update validation to check for Id instead of id\r\n        if (!user || typeof user.Id !== 'number') {\r\n            console.log('Invalid user object:', user);\r\n            return null;\r\n        }\r\n        return user;\r\n    } catch (err) {\r\n        console.error('Error parsing user:', err);\r\n        return null;\r\n    }\r\n};\r\n\r\nexport const api = {\r\n    // Auth operations\r\n    login: async (credentials: LoginRequest): Promise<User> => {\r\n        const response = await fetch(`${API_URL}/auth/login`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify(credentials),\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const error = await response.text();\r\n            throw new Error(error || 'Login failed');\r\n        }\r\n\r\n        const userData = await response.json();\r\n        \r\n        // Format the user data to handle both casings\r\n        const formattedUser = {\r\n            id: userData.id || userData.Id,\r\n            username: userData.username || userData.Username,\r\n            email: userData.email || userData.Email,\r\n            createdAt: new Date(userData.createdAt || userData.CreatedAt),\r\n            // Keep the original properties for backward compatibility\r\n            Id: userData.Id || userData.id,\r\n            Username: userData.Username || userData.username,\r\n            Email: userData.Email || userData.email,\r\n            CreatedAt: userData.CreatedAt || userData.createdAt\r\n        };\r\n\r\n        // Store the formatted user data in localStorage\r\n        localStorage.setItem('user', JSON.stringify(formattedUser));\r\n        return formattedUser;\r\n    },\r\n\r\n    register: async (userData: RegisterRequest): Promise<User> => {\r\n        const response = await fetch(`${API_URL}/auth/register`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify(userData),\r\n        });\r\n        if (!response.ok) {\r\n            const error = await response.text();\r\n            throw new Error(error || 'Registration failed');\r\n        }\r\n        return response.json();\r\n    },\r\n\r\n    // Note operations\r\n    getNotes: async (): Promise<Note[]> => {\r\n        const user = getCurrentUser();\r\n        if (!user?.Id) {\r\n            throw new Error('User not authenticated');\r\n        }\r\n\r\n        console.log('Fetching notes for user:', user.Id);\r\n\r\n        const response = await fetch(`${API_URL}/notes`, {\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'UserId': user.Id.toString()\r\n            }\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const error = await response.json();\r\n            throw new Error(error.message || 'Failed to fetch notes');\r\n        }\r\n\r\n        const notes = await response.json();\r\n        console.log('Raw API response:', notes);\r\n\r\n        // Convert from C# casing to TypeScript casing and filter by current user\r\n        const formattedNotes = notes\r\n            .map((note: any) => ({\r\n                id: note.id || note.Id,\r\n                title: note.title || note.Title,\r\n                content: note.content || note.Content,\r\n                category: note.category || note.Category,\r\n                createdAt: new Date(note.createdAt || note.CreatedAt),\r\n                updatedAt: new Date(note.updatedAt || note.UpdatedAt),\r\n                userId: note.userId || note.UserId,\r\n                isPublic: note.isPublic || note.IsPublic,\r\n                user: note.user || note.User\r\n            }))\r\n            .filter((note: Note) => note.userId === user.Id); // Properly type the note parameter\r\n\r\n        console.log('Formatted and filtered notes:', formattedNotes);\r\n        return formattedNotes;\r\n    },\r\n\r\n    createNote: async (note: Partial<Note>): Promise<Note> => {\r\n        const user = getCurrentUser();\r\n        if (!user?.Id) {\r\n            throw new Error('User not authenticated');\r\n        }\r\n\r\n        console.log('Creating note with data:', { ...note, userId: user.Id });\r\n\r\n        const response = await fetch(`${API_URL}/notes`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'UserId': user.Id.toString()\r\n            },\r\n            body: JSON.stringify({\r\n                title: note.title || '',\r\n                content: note.content || '',\r\n                category: note.category || '',\r\n                userId: user.Id\r\n            }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const error = await response.json();\r\n            console.error('Create note error:', error);\r\n            throw new Error(error.message || 'Failed to create note');\r\n        }\r\n\r\n        const createdNote = await response.json();\r\n        console.log('Server response:', createdNote);\r\n\r\n        // Convert from C# casing to TypeScript casing\r\n        const formattedNote: Note = {\r\n            id: createdNote.id || createdNote.Id,\r\n            title: createdNote.title || createdNote.Title,\r\n            content: createdNote.content || createdNote.Content,\r\n            category: createdNote.category || createdNote.Category,\r\n            createdAt: new Date(createdNote.createdAt || createdNote.CreatedAt),\r\n            updatedAt: new Date(createdNote.updatedAt || createdNote.UpdatedAt),\r\n            userId: createdNote.userId || createdNote.UserId,\r\n            isPublic: createdNote.isPublic || createdNote.IsPublic,\r\n            user: createdNote.user || createdNote.User\r\n        };\r\n\r\n        console.log('Formatted note:', formattedNote);\r\n        return formattedNote;\r\n    },\r\n\r\n    updateNote: async (id: number, note: Partial<Note>): Promise<Note> => {\r\n        try {\r\n            const response = await fetch(`${API_URL}/notes/${id}`, {\r\n                method: 'PUT',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({\r\n                    id,\r\n                    title: note.title || '',\r\n                    content: note.content || '',\r\n                    category: note.category || '',\r\n                    userId: note.userId\r\n                }),\r\n            });\r\n\r\n            if (!response.ok) {\r\n                const error = await response.text();\r\n                throw new Error(error || 'Failed to update note');\r\n            }\r\n\r\n            const updatedNote = await response.json();\r\n            return {\r\n                ...updatedNote,\r\n                createdAt: new Date(updatedNote.createdAt),\r\n                updatedAt: new Date(updatedNote.updatedAt)\r\n            };\r\n        } catch (err) {\r\n            console.error('Update error:', err);\r\n            throw err;\r\n        }\r\n    },\r\n\r\n    deleteNote: async (id: number): Promise<void> => {\r\n        const response = await fetch(`${API_URL}/notes/${id}`, {\r\n            method: 'DELETE',\r\n        });\r\n        if (!response.ok) {\r\n            const error = await response.text();\r\n            throw new Error(error || 'Failed to delete note');\r\n        }\r\n    },\r\n\r\n    shareNote: async (noteId: number, collaboratorId: number): Promise<void> => {\r\n        const user = getCurrentUser();\r\n        if (!user?.Id) {  // Changed from id to Id\r\n            throw new Error('User not authenticated');\r\n        }\r\n\r\n        const response = await fetch(`${API_URL}/notes/share`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'UserId': user.Id.toString()  // Changed from id to Id\r\n            },\r\n            body: JSON.stringify({\r\n                noteId,\r\n                collaboratorId\r\n            }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const error = await response.json();\r\n            throw new Error(error.message || 'Failed to share note');\r\n        }\r\n    },\r\n\r\n    getSharedNotes: async (): Promise<Note[]> => {\r\n        const user = getCurrentUser();\r\n        if (!user?.Id) {  // Changed from id to Id\r\n            throw new Error('User not authenticated');\r\n        }\r\n\r\n        const response = await fetch(`${API_URL}/notes/shared`, {\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'UserId': user.Id.toString()  // Changed from id to Id\r\n            }\r\n        });\r\n        \r\n        if (!response.ok) {\r\n            const error = await response.json();\r\n            throw new Error(error.message || 'Failed to fetch shared notes');\r\n        }\r\n        \r\n        const notes = await response.json();\r\n        return notes.map((note: any) => ({\r\n            ...note,\r\n            createdAt: new Date(note.createdAt),\r\n            updatedAt: new Date(note.updatedAt)\r\n        }));\r\n    },\r\n\r\n    makeNotePublic: async (id: number): Promise<void> => {\r\n        const user = getCurrentUser();\r\n        if (!user?.Id) {  // Changed from id to Id\r\n            throw new Error('User not authenticated');\r\n        }\r\n\r\n        const response = await fetch(`${API_URL}/notes/${id}/make-public`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'UserId': user.Id.toString()  // Changed from id to Id\r\n            },\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const error = await response.json();\r\n            throw new Error(error.message || 'Failed to make note public');\r\n        }\r\n    },\r\n\r\n    searchUsers: async (searchTerm: string): Promise<User[]> => {\r\n        const user = getCurrentUser();\r\n        if (!user?.Id) {\r\n            throw new Error('User not authenticated');\r\n        }\r\n\r\n        const response = await fetch(`${API_URL}/users/search?term=${encodeURIComponent(searchTerm)}`, {\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'UserId': user.Id.toString()\r\n            }\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const error = await response.json();\r\n            throw new Error(error.message || 'Failed to search users');\r\n        }\r\n\r\n        return response.json();\r\n    },\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}