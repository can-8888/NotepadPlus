{"ast":null,"code":"import * as signalR from '@microsoft/signalr';\nimport { getCurrentUser } from './api';\nimport { HubConnectionBuilder, LogLevel } from '@microsoft/signalr';\nclass SignalRService {\n  constructor() {\n    this.hubConnection = null;\n    this.connectionPromise = null;\n  }\n  async startConnection() {\n    try {\n      const user = getCurrentUser();\n      if (!user) {\n        console.log('No user found, not connecting to SignalR');\n        return;\n      }\n      if (this.connectionPromise) {\n        console.log('Connection already in progress');\n        return this.connectionPromise;\n      }\n      const token = localStorage.getItem('token');\n      if (!token) {\n        console.log('No token found, not connecting to SignalR');\n        return;\n      }\n      console.log('Starting SignalR connection...');\n      this.hubConnection = new HubConnectionBuilder().withUrl('http://localhost:5000/notificationHub', {\n        accessTokenFactory: () => token,\n        transport: signalR.HttpTransportType.WebSockets,\n        skipNegotiation: true\n      }).configureLogging(LogLevel.Debug).withAutomaticReconnect([0, 2000, 5000, 10000, 20000]).build();\n\n      // Add handlers before starting connection\n      this.setupConnectionHandlers(user.id);\n      this.connectionPromise = this.hubConnection.start();\n      await this.connectionPromise;\n      console.log('SignalR Connected!');\n      if (this.hubConnection.state === signalR.HubConnectionState.Connected) {\n        await this.hubConnection.invoke('JoinUserGroup', user.id.toString());\n        console.log(`Joined user group: User_${user.id}`);\n      }\n      this.connectionPromise = null;\n    } catch (err) {\n      console.error('Error establishing SignalR connection:', err);\n      this.connectionPromise = null;\n      throw err;\n    }\n  }\n  setupConnectionHandlers(userId) {\n    if (!this.hubConnection) return;\n    this.hubConnection.onclose(error => {\n      console.log('SignalR Connection closed:', error);\n    });\n    this.hubConnection.onreconnecting(error => {\n      console.log('SignalR Reconnecting:', error);\n    });\n    this.hubConnection.onreconnected(async connectionId => {\n      var _this$hubConnection;\n      console.log('SignalR Reconnected:', connectionId);\n      // Rejoin user group after reconnection\n      if (((_this$hubConnection = this.hubConnection) === null || _this$hubConnection === void 0 ? void 0 : _this$hubConnection.state) === signalR.HubConnectionState.Connected) {\n        try {\n          await this.hubConnection.invoke('JoinUserGroup', userId.toString());\n          console.log(`Rejoined user group: User_${userId}`);\n        } catch (err) {\n          console.error('Error rejoining user group:', err);\n        }\n      }\n    });\n  }\n  async stopConnection() {\n    try {\n      var _this$hubConnection2;\n      if (((_this$hubConnection2 = this.hubConnection) === null || _this$hubConnection2 === void 0 ? void 0 : _this$hubConnection2.state) === signalR.HubConnectionState.Connected) {\n        const user = getCurrentUser();\n        if (user) {\n          await this.hubConnection.invoke('LeaveUserGroup', user.id.toString());\n        }\n        await this.hubConnection.stop();\n        console.log('SignalR Disconnected');\n      }\n    } catch (err) {\n      console.error('Error stopping SignalR connection:', err);\n    }\n  }\n  onNotification(callback) {\n    if (this.hubConnection) {\n      console.log('Setting up notification handler');\n      this.hubConnection.on('ReceiveNotification', notification => {\n        console.log('Received notification:', notification);\n        callback(notification);\n      });\n    } else {\n      console.warn('No hubConnection available for notifications');\n    }\n  }\n  offNotification() {\n    if (this.hubConnection) {\n      this.hubConnection.off('ReceiveNotification');\n    }\n  }\n  isConnected() {\n    var _this$hubConnection3;\n    return ((_this$hubConnection3 = this.hubConnection) === null || _this$hubConnection3 === void 0 ? void 0 : _this$hubConnection3.state) === signalR.HubConnectionState.Connected;\n  }\n  async reconnect() {\n    var _this$hubConnection4;\n    if (((_this$hubConnection4 = this.hubConnection) === null || _this$hubConnection4 === void 0 ? void 0 : _this$hubConnection4.state) !== signalR.HubConnectionState.Connected) {\n      await this.startConnection();\n    }\n  }\n}\nexport const signalRService = new SignalRService();","map":{"version":3,"names":["signalR","getCurrentUser","HubConnectionBuilder","LogLevel","SignalRService","constructor","hubConnection","connectionPromise","startConnection","user","console","log","token","localStorage","getItem","withUrl","accessTokenFactory","transport","HttpTransportType","WebSockets","skipNegotiation","configureLogging","Debug","withAutomaticReconnect","build","setupConnectionHandlers","id","start","state","HubConnectionState","Connected","invoke","toString","err","error","userId","onclose","onreconnecting","onreconnected","connectionId","_this$hubConnection","stopConnection","_this$hubConnection2","stop","onNotification","callback","on","notification","warn","offNotification","off","isConnected","_this$hubConnection3","reconnect","_this$hubConnection4","signalRService"],"sources":["D:/_master/v5/notepad-plus/src/services/signalRService.ts"],"sourcesContent":["import * as signalR from '@microsoft/signalr';\r\nimport { getCurrentUser } from './api';\r\nimport { Notification } from './notificationService';\r\nimport { HubConnectionBuilder, LogLevel } from '@microsoft/signalr';\r\nimport { api } from './api';\r\n\r\nclass SignalRService {\r\n    private hubConnection: signalR.HubConnection | null = null;\r\n    private connectionPromise: Promise<void> | null = null;\r\n\r\n    public async startConnection() {\r\n        try {\r\n            const user = getCurrentUser();\r\n            if (!user) {\r\n                console.log('No user found, not connecting to SignalR');\r\n                return;\r\n            }\r\n\r\n            if (this.connectionPromise) {\r\n                console.log('Connection already in progress');\r\n                return this.connectionPromise;\r\n            }\r\n\r\n            const token = localStorage.getItem('token');\r\n            if (!token) {\r\n                console.log('No token found, not connecting to SignalR');\r\n                return;\r\n            }\r\n\r\n            console.log('Starting SignalR connection...');\r\n            this.hubConnection = new HubConnectionBuilder()\r\n                .withUrl('http://localhost:5000/notificationHub', {\r\n                    accessTokenFactory: () => token,\r\n                    transport: signalR.HttpTransportType.WebSockets,\r\n                    skipNegotiation: true\r\n                })\r\n                .configureLogging(LogLevel.Debug)\r\n                .withAutomaticReconnect([0, 2000, 5000, 10000, 20000])\r\n                .build();\r\n\r\n            // Add handlers before starting connection\r\n            this.setupConnectionHandlers(user.id);\r\n\r\n            this.connectionPromise = this.hubConnection.start();\r\n            await this.connectionPromise;\r\n            console.log('SignalR Connected!');\r\n\r\n            if (this.hubConnection.state === signalR.HubConnectionState.Connected) {\r\n                await this.hubConnection.invoke('JoinUserGroup', user.id.toString());\r\n                console.log(`Joined user group: User_${user.id}`);\r\n            }\r\n\r\n            this.connectionPromise = null;\r\n        } catch (err) {\r\n            console.error('Error establishing SignalR connection:', err);\r\n            this.connectionPromise = null;\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    private setupConnectionHandlers(userId: number) {\r\n        if (!this.hubConnection) return;\r\n\r\n        this.hubConnection.onclose((error) => {\r\n            console.log('SignalR Connection closed:', error);\r\n        });\r\n\r\n        this.hubConnection.onreconnecting((error) => {\r\n            console.log('SignalR Reconnecting:', error);\r\n        });\r\n\r\n        this.hubConnection.onreconnected(async (connectionId) => {\r\n            console.log('SignalR Reconnected:', connectionId);\r\n            // Rejoin user group after reconnection\r\n            if (this.hubConnection?.state === signalR.HubConnectionState.Connected) {\r\n                try {\r\n                    await this.hubConnection.invoke('JoinUserGroup', userId.toString());\r\n                    console.log(`Rejoined user group: User_${userId}`);\r\n                } catch (err) {\r\n                    console.error('Error rejoining user group:', err);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public async stopConnection() {\r\n        try {\r\n            if (this.hubConnection?.state === signalR.HubConnectionState.Connected) {\r\n                const user = getCurrentUser();\r\n                if (user) {\r\n                    await this.hubConnection.invoke('LeaveUserGroup', user.id.toString());\r\n                }\r\n                await this.hubConnection.stop();\r\n                console.log('SignalR Disconnected');\r\n            }\r\n        } catch (err) {\r\n            console.error('Error stopping SignalR connection:', err);\r\n        }\r\n    }\r\n\r\n    public onNotification(callback: (notification: Notification) => void) {\r\n        if (this.hubConnection) {\r\n            console.log('Setting up notification handler');\r\n            this.hubConnection.on('ReceiveNotification', (notification) => {\r\n                console.log('Received notification:', notification);\r\n                callback(notification);\r\n            });\r\n        } else {\r\n            console.warn('No hubConnection available for notifications');\r\n        }\r\n    }\r\n\r\n    public offNotification() {\r\n        if (this.hubConnection) {\r\n            this.hubConnection.off('ReceiveNotification');\r\n        }\r\n    }\r\n\r\n    public isConnected(): boolean {\r\n        return this.hubConnection?.state === signalR.HubConnectionState.Connected;\r\n    }\r\n\r\n    public async reconnect() {\r\n        if (this.hubConnection?.state !== signalR.HubConnectionState.Connected) {\r\n            await this.startConnection();\r\n        }\r\n    }\r\n}\r\n\r\nexport const signalRService = new SignalRService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}